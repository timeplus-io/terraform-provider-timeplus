// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"maps"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/timeplus-io/terraform-provider-timeplus/internal/timeplus"
	myvalidator "github.com/timeplus-io/terraform-provider-timeplus/internal/validator"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &sinkResource{}
var _ resource.ResourceWithImportState = &sinkResource{}

func NewSinkResource() resource.Resource {
	return &sinkResource{}
}

// sinkResource defines the resource implementation.
type sinkResource struct {
	client *timeplus.Client
}

// sinkResourceModel describes the sink resource data model.
type sinkResourceModel struct {
	ID          types.String `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Query       types.String `tfsdk:"query"`

	// Additional configurations such as broker url and etc. should be passed through `properties`
	Type types.String `tfsdk:"type"`

	// Additional properties (in JSON) that required to write the data to the sink (e.g. broker url). Please refer to the sinks documentation
	Properties types.String `tfsdk:"properties"`
}

func (r *sinkResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_sink"
}

func (r *sinkResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "Timeplus sinks run queries in background and send query results to the target system continuously.",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The sink immutable ID, generated by Timeplus",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "The human-friendly name for the sink",
				Required:            true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "A detailed text describes the sink",
				Optional:            true,
			},
			"query": schema.StringAttribute{
				MarkdownDescription: "The query the sink uses to generate data",
				Required:            true,
			},
			"type": schema.StringAttribute{
				MarkdownDescription: "The type of the sink, refer to the Timeplus document for supported sink types",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			// since Terraform does not have built-in support for map[string]any with the framework library, we use JSON as a simple solution
			"properties": schema.StringAttribute{
				MarkdownDescription: "A JSON object defines the configurations for the specific sink type. The properites could contain sensitive information like password, secret, etc.",
				Required:            true,
				Sensitive:           true,
				Validators: []validator.String{
					myvalidator.JsonObject(),
				},
			},
		},
	}
}

func (r *sinkResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*timeplus.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *timeplus.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *sinkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *sinkResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	props := make(map[string]any)
	// data.Properties uses the JsonObject validator, so it's guaranteed that it's a valid JSON object
	if data.Properties.ValueString() != "" {
		_ = json.Unmarshal([]byte(data.Properties.ValueString()), &props)
	}

	s := timeplus.Sink{
		Name:        data.Name.ValueString(),
		Description: data.Description.ValueString(),
		SQL:         data.Query.ValueString(),
		Type:        data.Type.ValueString(),
		Properties:  props,
	}

	if err := r.client.CreateSink(&s); err != nil {
		resp.Diagnostics.AddError("Error Creating Sink", fmt.Sprintf("Unable to create sink %q, got error: %s", s.Name, err))
		return
	}

	// set Computed fields
	data.ID = types.StringValue(s.ID)

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a timeplus_sink resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *sinkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *sinkResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	s, err := r.client.GetSink(data.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Reading Sink",
			fmt.Sprintf("Unable to read sink %q, got error: %s",
				data.Name.ValueString(), err))
		return
	}

	// required fields
	data.Name = types.StringValue(s.Name)
	data.Query = types.StringValue(s.SQL)
	data.Type = types.StringValue(s.Type)

	// We can't compare the JSON directly since order is not guaranteed, need a bit more work to detect if properties are acutally changed
	props := make(map[string]any)
	if data.Properties.ValueString() != "" {
		_ = json.Unmarshal([]byte(data.Properties.ValueString()), &props)
	}

	clone := maps.Clone(props)

	// API does not return sensitive fields, thus we can't simply use s.Properties to replace data.Properties
	maps.Copy(props, s.Properties)

	if !reflect.DeepEqual(clone, props) {
		propsBytes, err := json.Marshal(s.Properties)
		if err != nil {
			resp.Diagnostics.AddError("Bad Sink Properties", fmt.Sprintf("Unable to encode sink properties into JSON, got error: %s", err))
			return
		}
		data.Properties = types.StringValue(string(propsBytes))
	}

	// optional fields
	if !(data.Description.IsNull() && s.Description == "") {
		data.Description = types.StringValue(s.Description)
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *sinkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *sinkResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	props := make(map[string]any)
	// data.Properties uses the JsonObject validator, so it's guaranteed that it's a valid JSON object
	if data.Properties.ValueString() != "" {
		_ = json.Unmarshal([]byte(data.Properties.ValueString()), &props)
	}

	s := timeplus.Sink{
		ID:          data.ID.ValueString(),
		Name:        data.Name.ValueString(),
		Description: data.Description.ValueString(),
		SQL:         data.Query.ValueString(),
		Type:        data.Type.ValueString(),
		Properties:  props,
	}

	if err := r.client.UpdateSink(&s); err != nil {
		resp.Diagnostics.AddError("Error Updating Sink", fmt.Sprintf("Unable to update sink %q, got error: %s", s.Name, err))
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *sinkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *sinkResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteSink(&timeplus.Sink{ID: data.ID.ValueString()})
	if err != nil {
		resp.Diagnostics.AddError("Error Deleting Sink", fmt.Sprintf("Unable to delete sink %q, got error: %s", data.Name.ValueString(), err))
	}
}

func (r *sinkResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
